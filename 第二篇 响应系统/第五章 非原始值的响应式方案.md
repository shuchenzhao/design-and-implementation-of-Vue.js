在本章中，我们首先介绍了 Proxy 与 Reflect。 vue.js3的响应式数据是基于 Proxy实现的，proxy可以为其他对象创建一个代理对象。所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。在实现代理的过程中，我们遇到了访回器属性的this指向问题，这需要使用 Reflect.*方法并指定正确的receiver 来解决。

然后我们详细讨论了 JavaScript 中对象的概念，以及 proxy 的工作原理。在 ECMAScript 规范中，Javascript 中有两种对象，其中一种叫作常规对象，另一种叫作异质对象。满足以下三点要求的对象就是常规对象：

口对于表5-1 给出的内部方法，必领使用规范 10.1.x 节给出的定义实现；

口对于内部方法 [[Call]]，必须使用规范 10.2.1 书给出的定义实现;

口对于内部方法 [[Construct]]，必须使用规范 10.2.2 节给出的定义实现。

而所有不符合这三太要求的对象都是异质对象。一个对象是函数还是其他对象，是由部要在该对象上的内部方法和内部槽决定的。

接者，我们讨论丁关于对象 object 的代理。代理对象的本质，就是在查阅规范并我到可拦截的基本操作的方法。有一些操作并不是基本操作，而是复合操作，这需要我们查阅规范了解它们都依赖哪些基本操作，从而通过基本操作的拦截方法间接地处理复合操作。我们还详细分析了添加、修改、删除属性对 for….in操作的影响，其中添加和删除属性都会影响for……tn 循环的执行次数，所以当这些操作发生时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。而修改属性值则不影响 for...in 循环的执行次数，因此无须处理。我们还讨论了如何合理地触发副作用函数重新执行，包括对 NaN 的处理，以区访问原型链上的属性导致的副作用函数重新执行两次的问题。对于 NaN， 我们主要注意的是NaN === NaN永远等于 false。对于原型链属性问题，需要我们查阅规范定位问题的原因。由此可见，想要基于 Proxy 实现—个相对完善的响应系统，免不了去了解 ECMAScript 规范。

而后，我们讨论了深响应与浅响应，以及深只读与浅只读。这里的深和浅指的是对象的层级，浅响应（或只读）代表仅代理一个对象的第一层属性，即只有对象的第一层属性值是响应 （或只读）的。深响应(或只读）则恰恰相反，为了实现深响应 (或只读），我们需要在返回属性值之前，对值做一层包装，将其包装为响应式（或只读）数据后再返回。

之后，我们讨论了关于数组的代理。数组是一个异质对象，因为数组对象部署的内部方法[[DefineOwnProperty]]不同于常规对象。通过索引为数组设置新的元素，可能会隐式地改变数组length属性的值。对应地，修改数组 length属性的值，也可能会间接影响数组中的已有元素。

所以在触发响应的时候需要额外注意。我们还讨论了如何拦截for…in 和 for...of 对数组的遍历操作。使用for...in 循环遍历数组与遍历普通对象区别不大，唯一需要注意的是，当追踪for..in操作时，应该使用数组的 length作为追踪的key。 for...of基于迭代协议工作，数组内建了 Symbol.iterator 方法。根据规范的 23.1.5.1 节可知，数组迭代器执行时，会读取数组的 length 属性或数组的索引。因此，我们不需要做其他额外的处理，就能够实现对 for..of 迭代的响应式支特。

我们还讨论了致组的查找方法。如 includes、indexOf 以及 lastIndexOf 等。对于数组元素的查找，需要注意的一点是，用户既可能使用代理对象进行查找，也可能使用原始对象进行查找。

为了支持这两种形式，我们需要重写数组的查我方法。原理很简单，当用户使用这些方法查找元素时，我们可以先去代理对象中查找，如果我不到，再去原始数组中查找。

我们还介绍了会隐式修政数组长度的原型方法，即push、pop、shitft、unshift 以及splice等方法。调用这些方法会间接地读取和设置数组的 length 属性，因此，在不同的副作用函数内对同一个数组执行上述方法，会导致多个副作用两数之回循环调用，最终导致调用栈滥出。为了解决这个问题，我们使用一个标记变量 shouldTrack 來代表是否允许进行追踪，然后重写了上述这些方法，目的是，当这些方法间接读取 length属性值时，我们会先将 shouldTrack 的值设置为false， 即禁止追踪。这样就可以断开 length 属性与副作用函数之间的响应联系，从而避免循环调用导致的调用栈溢出。

最后，我们讨论了关于集合类型数据的响应式方案。集合类型指 set、Map、weakset 以及weakMap。我们讨论了使用 proxy 为集合类型创建代理对象的一些注意事项。集合类型不同于普通对象，它有特定的数据操作方法。当使用 Proxy代理集合类型的数据时要格外注意，例如，集合类型的 size属性是一个访问器属性，当通过代理对象访问 size 属性时，由于代理对象本身并没有部署 [[SetData]] 这样的内部槽，所以会发生错误。另外，通过代理对象执行集合类型的操作方法时，要注意这些方法执行时的 this 指向，我们需要在get 拦截函数内通过.bind 函数为这些方法鄉定正确的 this值。我们还讨论了集合类型响应式数据的实现。我们需要通过“重写”集合方法的方式来实现自定义的能力，当 set 集合的 add 方法执行时，需要调用 trigger 函数触发响应。我们也讨论了关于 “数据污染”的问题。数据污染指的是不小心将响应式数据添加到原始数据中，它导致用户可以通过原始数据执行响应式相关操作，这不是我们所期望的。为了避免这类问题发生，我们通过响应式数据对象的raw属性来访问对应的原始数据对象，后续操作使用原始数据对象就可以了。我们还讨论了关于集合类型的遍历，即 forEach 方法。集合的forEach 方法与对象的 for...in遍历类似，最大的不同体现在，当使用for.…in遍历对象时，我们只关心对象的键是否变化，而不关心值；但使用forEach遍历集合时，我们既关心键的变化，也关心值的变化。